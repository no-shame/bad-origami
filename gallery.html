<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Gallery</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <link type="text/css" rel="stylesheet" href="main.css">
        <style>
            #blocker {
                position: absolute;
                width: 100%;
                height: 100%;
                background-color: rgba(0,0,0,0.5);
            }

            #instructions {
                width: 100%;
                height: 100%;

                display: -webkit-box;
                display: -moz-box;
                display: box;

                -webkit-box-orient: horizontal;
                -moz-box-orient: horizontal;
                box-orient: horizontal;

                -webkit-box-pack: center;
                -moz-box-pack: center;
                box-pack: center;

                -webkit-box-align: center;
                -moz-box-align: center;
                box-align: center;

                color: #ffffff;
                text-align: center;
                font-family: Arial;
                font-size: 14px;
                line-height: 24px;

                cursor: pointer;
            }
        </style>
    </head>
    <body>

        <div id="blocker">

            <div id="instructions">
<!--                 <span style="font-size:36px">Click to play</span> -->
<!--                 <br /><br />
                Move: WASD<br/>
                Jump: SPACE<br/>
                Look: MOUSE -->

                <img src="images/keys.png" alt="W3Schools.com"> 
            
            </div>


        </div>

        <script type="module">

            import * as THREE from 'https://threejs.org/build/three.module.js';
            import { PointerLockControls } from 'https://threejs.org/examples/jsm/controls/PointerLockControls.js';

            var camera, scene, renderer, controls;

            var objects = [];

            var raycaster;

            var moveForward = false;
            var moveBackward = false;
            var moveLeft = false;
            var moveRight = false;
            var canJump = false;

            var movementSpeed = 1500;
            var boxAmount = 1000;
            var boxSpread = 100;

            var bgColor = 0xbbddff;
            var boxMaterial;

            var floor;
            var floorBits = [];

            var fontSize = 10;

            var iMustGo = false;
            var exponential = 0;

            var prevTime = performance.now();
            var velocity = new THREE.Vector3();
            var direction = new THREE.Vector3();
            var vertex = new THREE.Vector3();
            var color = new THREE.Color();

            init();





            // instantiate a loader
            var loader = new THREE.TextureLoader();


            const texture1 = loader.load( 'images/snap0.jpg' );
            const texture2 = loader.load( 'images/snap1.jpg' );
            const texture3 = loader.load( 'images/snap2.jpg' );
            const texture4 = loader.load( 'images/snap3.jpg' );
            const texture5 = loader.load( 'images/snap4.jpg' );



            // load a resource
            loader.load(
                // resource URL
                'images/snap5.jpg',

                // onLoad callback
                function ( texture6 ) {


                    scene.traverse(object => {
                        
                        if(object.type === 'Mesh') {
                            var rand = Math.random();
                            if(rand < 0.15)
                                object.material.map = texture1;
                            if(rand >= 0.15 && rand < 0.30)
                                object.material.map = texture2;
                            if(rand >= 0.30 && rand < 0.45)
                                object.material.map = texture3;
                            if(rand >= 0.45 && rand < 0.60)
                                object.material.map = texture4;
                           if(rand >= 0.60 && rand < 0.75)
                                object.material.map = texture5;
                           if(rand >= 0.75 )
                                object.material.map = texture6;
                        }
                    });


                    animate();
                },

                // onError callback
                function ( err ) {
                    console.error( 'An error happened.' );
                }
            );














                var loader = new THREE.FontLoader();
                loader.load( 'fonts/helvetiker_regular.typeface.json', function ( font ) {

                    var xMid, text;

                    var color = 0x000000;


                    var matLite = new THREE.MeshBasicMaterial( {
                        color: color,
                        transparent: true,
                        opacity: 1.0,
                        side: THREE.DoubleSide
                    } );

                    var message = "If you're ready to leave, \nyou can press F.";

                    var shapes = font.generateShapes( message, fontSize );

                    var geometry = new THREE.ShapeBufferGeometry( shapes );

                    geometry.computeBoundingBox();

                    xMid = - 0.5 * ( geometry.boundingBox.max.x - geometry.boundingBox.min.x );

                    geometry.translate( xMid, 0, 0 );

                    // make shape ( N.B. edge view not visible )

                    text = new THREE.Mesh( geometry, matLite );
                    text.position.z = -800;
                    text.position.y = -50;
                    text.rotation.x = -Math.PI/2;
                    scene.add( text );

                    // make line shape ( N.B. edge view remains visible )

                    var holeShapes = [];

                    for ( var i = 0; i < shapes.length; i ++ ) {

                        var shape = shapes[ i ];

                        if ( shape.holes && shape.holes.length > 0 ) {

                            for ( var j = 0; j < shape.holes.length; j ++ ) {

                                var hole = shape.holes[ j ];
                                holeShapes.push( hole );

                            }

                        }

                    }

                    shapes.push.apply( shapes, holeShapes );


                } ); //end load function



















            function init() {

                camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 );
                camera.position.y = 10;

                scene = new THREE.Scene();
                scene.background = new THREE.Color( bgColor );
                scene.fog = new THREE.Fog( bgColor, 0, 1000 );

                var light = new THREE.HemisphereLight( bgColor, bgColor, 1.1 );
                light.position.set( 0.5, 1, 0.75 );
                scene.add( light );

                controls = new PointerLockControls( camera, document.body );

                var blocker = document.getElementById( 'blocker' );
                var instructions = document.getElementById( 'instructions' );

                instructions.addEventListener( 'click', function () {

                    controls.lock();

                }, false );

                controls.addEventListener( 'lock', function () {

                    instructions.style.display = 'none';
                    blocker.style.display = 'none';

                } );

                controls.addEventListener( 'unlock', function () {

                    blocker.style.display = 'block';
                    instructions.style.display = '';

                } );

                scene.add( controls.getObject() );

                var onKeyDown = function ( event ) {

                    console.log(event.keyCode);

                    switch ( event.keyCode ) {

                        case 38: // up
                        case 87: // w
                            moveForward = true;
                            break;

                        case 37: // left
                        case 65: // a
                            moveLeft = true;
                            break;

                        case 40: // down
                        case 83: // s
                            moveBackward = true;
                            break;

                        case 39: // right
                        case 68: // d
                            moveRight = true;
                            break;

                        // case 32: // space
                        //     if ( canJump === true ) velocity.y += 650;
                        //     canJump = false;
                        //     break;
                        case 70: 
                            iMustGo = true;

                    }

                };

                var onKeyUp = function ( event ) {

                    switch ( event.keyCode ) {

                        case 38: // up
                        case 87: // w
                            moveForward = false;
                            break;

                        case 37: // left
                        case 65: // a
                            moveLeft = false;
                            break;

                        case 40: // down
                        case 83: // s
                            moveBackward = false;
                            break;

                        case 39: // right
                        case 68: // d
                            moveRight = false;
                            break;

                    }

                };

                document.addEventListener( 'keydown', onKeyDown, false );
                document.addEventListener( 'keyup', onKeyUp, false );

                raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, - 1, 0 ), 0, 10 );

                // floor

                var floorGeometry = new THREE.PlaneBufferGeometry( 150, 150, 1, 1 );
                floorGeometry.rotateX( - Math.PI / 2 );

                // vertex displacement

                var position = floorGeometry.attributes.position;

                for ( var i = 0, l = position.count; i < l; i ++ ) {

                    // vertex.fromBufferAttribute( position, i );

                    // vertex.x += Math.random() * 20 - 10;
                    // vertex.y += Math.random() * 2;
                    // vertex.z += Math.random() * 20 - 10;

                    // position.setXYZ( i, vertex.x, vertex.y, vertex.z );

                }

                floorGeometry = floorGeometry.toNonIndexed(); // ensure each face has unique vertices

                position = floorGeometry.attributes.position;
                var colors = [];

                for ( var i = 0, l = position.count; i < l; i ++ ) {

                    color.setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.75 + 0.25 );
                    colors.push( color.r, color.g, color.b );

                }

                floorGeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );

                var floorMaterial = new THREE.MeshBasicMaterial( { vertexColors: true, side: THREE.DoubleSide } );

                floor = new THREE.Mesh( floorGeometry, floorMaterial );
                //scene.add( floor );
                floorBits.push( floor );
                floor = new THREE.Mesh( floorGeometry, floorMaterial );
                //scene.add( floor );
                floorBits.push( floor );
                                floor = new THREE.Mesh( floorGeometry, floorMaterial );
                //scene.add( floor );
                floorBits.push( floor );


                // objects

                var boxGeometry = new THREE.BoxBufferGeometry( 2.5, 20, 20 );
                boxGeometry = boxGeometry.toNonIndexed(); // ensure each face has unique vertices

                position = boxGeometry.attributes.position;
                colors = [];

                for ( var i = 0, l = position.count; i < l; i ++ ) {

                    color.setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
                    colors.push( color.r, color.g, color.b );

                }

                boxGeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );

                for ( var i = 0; i < boxAmount; i ++ ) {

                    boxMaterial = new THREE.MeshPhongMaterial( { specular: 0xffffff, flatShading: true, vertexColors: false } );
                    boxMaterial.color.setHSL( 1, 1 ,1);

                    var box = new THREE.Mesh( boxGeometry, boxMaterial );
                    box.position.x = Math.floor( Math.random() * 20 - 10 ) * boxSpread;
                    box.position.y = Math.floor( Math.random() * 20 ) * 20 + 10;
                    box.position.z = Math.floor( Math.random() * 20 - 10 ) * boxSpread;

                    if(Math.random() > 0.75)
                      box.rotation.y = Math.PI / 2;


                    var scale = Math.random() * 2.0 + 1.0;
                    box.scale.set(scale, scale, scale);

                    scene.add( box );
                    objects.push( box );

                }

                //

                renderer = new THREE.WebGLRenderer( { antialias: true } );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                document.body.appendChild( renderer.domElement );

                //

                window.addEventListener( 'resize', onWindowResize, false );

            }

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

            }

            function animate() {

                requestAnimationFrame( animate );

                var i = 0;
                floorBits.forEach(function(floor) {


                  if(floor.position.x < controls.getObject().position.x - 50 || floor.position.x > controls.getObject().position.x + 50)
                        floor.position.x = controls.getObject().position.x;

                  if(floor.position.z < controls.getObject().position.z - 50 || floor.position.z > controls.getObject().position.z + 50)
                        floor.position.z = controls.getObject().position.z;
                  // floor.position.z = controls.getObject().position.z;
                  i++;
                });





                if ( controls.isLocked === true ) {

                    raycaster.ray.origin.copy( controls.getObject().position );
                    raycaster.ray.origin.y -= 10;

                    var intersections = raycaster.intersectObjects( objects );

                    var onObject = intersections.length > 0;

                    var time = performance.now();
                    var delta = ( time - prevTime ) / 1000;

                    velocity.x -= velocity.x * 10.0 * delta;
                    velocity.z -= velocity.z * 10.0 * delta;


                    if(!iMustGo)
                    velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass


                    direction.z = Number( moveForward ) - Number( moveBackward );
                    direction.x = Number( moveRight ) - Number( moveLeft );
                    direction.normalize(); // this ensures consistent movements in all directions

                    if ( moveForward || moveBackward ) velocity.z -= direction.z * movementSpeed * delta;
                    if ( moveLeft || moveRight ) velocity.x -= direction.x * movementSpeed * delta;

                    if ( onObject === true ) {

                        velocity.y = Math.max( 0, velocity.y );
                        canJump = true;

                    }

                    controls.moveRight( - velocity.x * delta );
                    controls.moveForward( - velocity.z * delta );

                    controls.getObject().position.y += ( velocity.y * delta ); // new behavior


                    if(iMustGo){
                        console.log("I must go");
                        exponential = exponential + 0.001;
                        controls.getObject().position.y += exponential * 0.25;
                        controls.getObject().position.z += exponential * 2;
                    }

                    if ( controls.getObject().position.y < 10 ) {

                        velocity.y = 0;
                        controls.getObject().position.y = 10;

                        canJump = true;

                    }

                    prevTime = time;

                }

                renderer.render( scene, camera );

            }

        </script>
    </body>
</html>